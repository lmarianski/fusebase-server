<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">api/Module.js | FuseBase</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="A C&amp;C server made in nodejs"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="FuseBase"><meta property="twitter:description" content="A C&amp;C server made in nodejs"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/lukas2005/FuseBase.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/api/Module.js~Module.html">Module</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">api/Module.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * Export the module
 */
module.exports = class Module {
	
	/**
	 * The default constructor
	 */
	constructor() {
		/**
		 * @type {object[]}
		 * @private
		 */
		this.remoteFunctions = {};
		
		/**
		 * @type {object[]}
		 * @private
		 */		
		this.deps = [];

		/**
		 * @type {object[]}
		 * @private
		 */
		this.controlPanelEvents = [];

		/**
		 * @type {string[]}
		 * @private
		 */
		this.widgetPaths = [];

		/**
		 * @type {function}
		 * @private
		 */	
		this.mainFunc = null;

		/**
		 * @type {string}
		 * Name of this module
		 */		
		this.name = &quot;&quot;;

		/**
		 * @type {boolean}
	 	 * Does this module appear in the control panel as a toggleable auto run module?
		 */		
		this.isAutoRun = true;

		/**
		 * @type {*}
		 */		
		this.config = {};

		this.main = Module.main;
	}
	
	/**
	 * Sets the name of this module. If it stays unset then the name of the file/folder is used
	 * @param {string} name New name
	 */
	setName(name) {
		this.name = name;
	}
	
	/**
	 * Adds a new remote function to this module
	 * @param {string} name Name of the remote function
	 * @param {function(data:*, debug:boolean): void} func Remote function&apos;s code {EXECUTED ON THE TARGET}. the debug option is set by the server and it should be used when doing any logging, the data object is the same one as provided when executing the function
	 */
	addRemoteFunction(name, func) {
		this.remoteFunctions[name] = func;
	}
	
	/**
	 * Executes a remote function on the provided socket
	 * @param {SocketIO.Socket} socket Socket to execute teh function on
	 * @param {Module} module Module defining the function
	 * @param {string} funcName Name of the function
	 * @param {*[]} args Arguments to pass to the function
	 * @param {function(out: *): void} callback Callback
	 * @static
	 */
	executeRemoteFunc(socket, module, funcName, args, callback) {
		let finalObj = {};
		
		finalObj.func = module.remoteFunctions[funcName].toString();
		finalObj.args = args;
		finalObj.deps = module.deps;
		
		socket.emit(&quot;executeRemoteFunction&quot;, finalObj, socket.debugExecFunc, funcName);

		//if (!socket.eventNames().includes(funcName+&quot;Out&quot;)) {
			let listener = (out) =&gt; {
				socket.removeListener(funcName+&quot;Out&quot;, listener);

				if (callback != null) callback(out);
			};
			socket.on(funcName+&quot;Out&quot;, listener);
		//}
	}	

	/**
	 * Executes a remote function on the provided socket, but uses this as the module parameter
	 * @param {SocketIO.Socket} socket Socket to execute teh function on
	 * @param {string} funcName Name of the function
	 * @param {*[]} args Arguments to pass to the function
	 * @param {function(out: *): void} callback Callback, Optional
	 * @static
	 */
	executeRemoteFuncFromThisModule(socket, funcName, args, callback) {
		this.executeRemoteFunc(socket, this, funcName, args, callback);
	}	

	/**
	 * Adds a dependency to this module. Useful for including libraries that must be present on the target for execution of the remote function(s)
	 * @param {string} url Url to the js file that is going to get included
	 * @param {string} integrity Sets the integrity and crossoigin parameters of the script tag (SRI)
	 * @see https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity
	 */
	addDependencies(url, integrity) {
		let dep = {};
		dep.url = url;
		dep.integrity = integrity || null;
		this.deps.push(dep);
	}	
	
	/**
	 * Sets the default config obj
	 * @param {*} config Object that is provided to you in the main function. Useful if you want to make your module configurable
	 */
	setDefaultConfig(config) {
		this.config = config;

		this.main.onModuleConfigChange(this, this.config, true);
	}
	
	/**
	 * Sets a value of the config object
	 * @param {*} key 
	 * @param {*} val 
	 */
	setConfigOpt(key, val) {
		this.config[key] = val;

		this.main.onModuleConfigChange(this, this.config);
	}	
	
	/**
	 * Sets the main function of the module.
	 * @param {function} mainFunc main function of the module {EXECUTED ON THE SERVER}
	 */
	setMainFunction(mainFunc) {
		this.mainFunc = mainFunc;
	}	
	
	/**
	 * Should this module appear in the control panel as a toggleable auto run module?
	 * @param {boolean} bool 
	 */
	setAutoRunStatus(bool) {
		this.isAutoRun = bool;
	}
	
	/**
	 * Used for communication with the control panel. After adding an event you can emit it (in the control panel script) by calling socket.emit(&quot;name&quot;, &quot;data&quot;); the data parameter is going to get returned in the first param of the callback function
	 * @param {string} name 
	 * @param {function(data:*, masterSocket:SocketIO.Socket, slaveSockets:SocketIO.Socket[]): void} func - this is function param.
	 */
	addControlPanelEvent(name, func) {
		this.controlPanelEvents.push({
			function: func,
			name: name
		});
	}

	/**
	 * Executes the module
	 * @param {SocketIO.Socket} socket SocketIO socket to execute the module on.
	 * @param {*} config [Optional] The config object. If not specified the default config object is used
	 */
	exec(socket, config) {
		return this.mainFunc(this, socket, config || this.config);
	}


	update() {
		if (this.main.getModuleSettings()[this.name]) {
			this.config = this.main.getModuleSettings()[this.name];

			console.log(this.config);
		}
	}
};</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
